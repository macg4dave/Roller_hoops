/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/v1/devices": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List devices */
        get: {
            parameters: {
                query?: {
                    /** @description Optional search query (matches id, display name, metadata, IPs, MACs, and SNMP fields). */
                    q?: string;
                    /** @description Optional status filter. */
                    status?: "online" | "offline" | "changed";
                    /** @description Sort order (cursor uses this sort key). */
                    sort?: "created_desc" | "last_seen_desc" | "last_change_desc";
                    limit?: number;
                    /** @description Cursor returning `sort_ts|device_id` from the prior page. */
                    cursor?: string;
                    /** @description Lookback window for online/offline filtering (defaults to 1 hour). */
                    seen_within_seconds?: number;
                    /** @description Lookback window for changed filtering (defaults to 24 hours). */
                    changed_within_seconds?: number;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DevicePage"];
                    };
                };
            };
        };
        put?: never;
        /** Create a device */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["DeviceCreate"];
                };
            };
            responses: {
                /** @description Created */
                201: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Device"];
                    };
                };
                /** @description Bad request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/devices/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        /** Get device by ID */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Device"];
                    };
                };
                /** @description Invalid ID */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
            };
        };
        /** Update device by ID */
        put: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    id: string;
                };
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["DeviceUpdate"];
                };
            };
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Device"];
                    };
                };
                /** @description Invalid request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
            };
        };
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/devices/{id}/name-candidates": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        /**
         * List name candidates for a device
         * @description Returns friendly-name candidates discovered via enrichment (e.g. reverse DNS, SNMP sysName).
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DeviceNameCandidate"][];
                    };
                };
                /** @description Invalid ID */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/devices/{id}/facts": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        /**
         * Get current device facts
         * @description Returns current discovery/enrichment facts for a device (IPs, MACs, interfaces, services, SNMP snapshot, and adjacency links).
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DeviceFacts"];
                    };
                };
                /** @description Invalid ID */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/devices/export": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Export devices as a JSON snapshot
         * @description Returns the complete list of devices, including metadata, as a downloadable JSON document.
         */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Exported devices */
                200: {
                    headers: {
                        /** @description Indicates the downloaded filename. */
                        "Content-Disposition"?: string;
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["Device"][];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/devices/import": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Import devices from a JSON snapshot
         * @description Accepts a list of devices to create or update. Existing devices are matched by ID and updated, while new entries are created.
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["DeviceImportPayload"];
                };
            };
            responses: {
                /** @description Import result summarizing created and updated records */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DeviceImportResult"];
                    };
                };
                /** @description Invalid request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/discovery/run": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Trigger a discovery pass */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["DiscoveryRunRequest"];
                };
            };
            responses: {
                /** @description Accepted */
                202: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DiscoveryRun"];
                    };
                };
                /** @description Bad request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/discovery/status": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get discovery status */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DiscoveryStatus"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/discovery/runs": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List discovery runs */
        get: {
            parameters: {
                query?: {
                    limit?: number;
                    /** @description Cursor returning `started_at|id` from the prior page. */
                    cursor?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Discovery run list */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DiscoveryRunPage"];
                    };
                };
                /** @description Invalid request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/discovery/runs/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        /** Get discovery run by ID */
        get: {
            parameters: {
                query?: never;
                header?: never;
                path: {
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Discovery run detail */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DiscoveryRun"];
                    };
                };
                /** @description Invalid ID */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/discovery/runs/{id}/logs": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        /** List logs for a discovery run */
        get: {
            parameters: {
                query?: {
                    limit?: number;
                    /** @description Cursor representing `created_at|log_id` for pagination. */
                    cursor?: string;
                };
                header?: never;
                path: {
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Discovery run logs */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DiscoveryRunLogPage"];
                    };
                };
                /** @description Invalid request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Run not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/inventory/netbox/import": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Import devices from a NetBox export payload
         * @description Accepts a NetBox API payload (or an extracted device list) and imports devices into the local catalog.
         *     The request wraps the upstream JSON as `payload` so unknown upstream fields do not break strict decoding.
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["InventoryImportRequest"];
                };
            };
            responses: {
                /** @description Imported inventory */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["InventoryImportResult"];
                    };
                };
                /** @description Invalid request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Database not configured */
                503: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/devices/changes": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** List device change events */
        get: {
            parameters: {
                query?: {
                    /** @description Inclusive RFC3339 timestamp filter (newer than or equal to value). */
                    since?: string;
                    limit?: number;
                    /** @description Cursor from a previous page (`event_at|event_id`). */
                    cursor?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Device change feed */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DeviceChangeFeed"];
                    };
                };
                /** @description Invalid request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/devices/{id}/history": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                id: string;
            };
            cookie?: never;
        };
        /**
         * Device history timeline
         * @description Returns the change events for a single device, ordered newest-first. Supports pagination via `limit` and `cursor`.
         */
        get: {
            parameters: {
                query?: {
                    limit?: number;
                    /** @description Cursor returned from the previous page (`event_at|event_id`). */
                    cursor?: string;
                };
                header?: never;
                path: {
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Device history */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["DeviceChangeFeed"];
                    };
                };
                /** @description Invalid request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Device not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/inventory/nautobot/import": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Import devices from a Nautobot export payload
         * @description Accepts a Nautobot API payload (or an extracted device list) and imports devices into the local catalog.
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["InventoryImportRequest"];
                };
            };
            responses: {
                /** @description Imported inventory */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["InventoryImportResult"];
                    };
                };
                /** @description Invalid request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Database not configured */
                503: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/audit/events": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Record an audit event
         * @description Minimal audit log write endpoint intended to be called by the UI (which owns auth/sessions).
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody: {
                content: {
                    "application/json": components["schemas"]["AuditEventCreate"];
                };
            };
            responses: {
                /** @description Created */
                201: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": {
                            ok?: boolean;
                        };
                    };
                };
                /** @description Invalid request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Database not configured */
                503: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/v1/map/{layer}": {
        parameters: {
            query?: never;
            header?: never;
            path: {
                layer: components["schemas"]["MapLayer"];
            };
            cookie?: never;
        };
        /**
         * Get a layer projection (focus-scoped)
         * @description Returns a small, render-ready projection for a single layer and (optional) focus.
         *
         *     No focus is valid and returns an empty projection plus guidance (200 OK).
         *
         *     Responses are deterministic: `regions`, `nodes`, and `edges` are sorted by stable `id`.
         */
        get: {
            parameters: {
                query?: {
                    /** @description Focus type for object-first navigation (must be provided together with `focusId`). */
                    focusType?: components["schemas"]["MapFocusType"];
                    /** @description Focus identifier (must be provided together with `focusType`; UUID for `device`; other types are layer-defined). */
                    focusId?: string;
                    /** @description Optional scoping hint (small integer). */
                    depth?: number;
                    /** @description Optional hard cap hint (the API may clamp further). */
                    limit?: number;
                };
                header?: never;
                path: {
                    layer: components["schemas"]["MapLayer"];
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description OK */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["MapProjection"];
                    };
                };
                /** @description Invalid request */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Focus not found */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Database not configured */
                503: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /**
         * @description Mutually-exclusive layer identifier.
         * @enum {string}
         */
        MapLayer: "physical" | "l2" | "l3" | "services" | "security";
        /**
         * @description Focus type for map projections.
         * @enum {string}
         */
        MapFocusType: "device" | "subnet" | "vlan" | "zone" | "service";
        MapFocus: {
            type: components["schemas"]["MapFocusType"];
            id: string;
            /** @description Optional human-friendly label (best-effort). */
            label?: string | null;
        };
        MapTruncationMetric: {
            returned: number;
            limit: number;
            truncated: boolean;
            /** @description Optional total size hint when known. */
            total?: number | null;
            /** @description Optional operator-facing truncation message. */
            warning?: string | null;
        };
        MapTruncation: {
            regions: components["schemas"]["MapTruncationMetric"];
            nodes: components["schemas"]["MapTruncationMetric"];
            edges: components["schemas"]["MapTruncationMetric"];
        };
        MapRegion: {
            /** @description Stable region identifier within the projection. */
            id: string;
            /** @description Region kind (e.g. subnet, vlan, zone). */
            kind: string;
            label: string;
            parent_region_id?: string | null;
            meta?: {
                [key: string]: unknown;
            } | null;
        };
        MapNode: {
            /** @description Stable node identifier within the projection. */
            id: string;
            /** @description Node kind (e.g. device, interface, service). */
            kind: string;
            label?: string | null;
            /** @description Deterministic primary region placement (when applicable). */
            primary_region_id?: string | null;
            /** @description Region membership (container ids); membership should not be expressed as dense mesh edges. */
            region_ids: string[];
            meta?: {
                [key: string]: unknown;
            } | null;
        };
        MapEdge: {
            id: string;
            /** @description Edge kind (layer-defined; edges are rare/intentional). */
            kind: string;
            /** @description Source node id. */
            from: string;
            /** @description Target node id. */
            to: string;
            label?: string | null;
            meta?: {
                [key: string]: unknown;
            } | null;
        };
        MapInspectorField: {
            label: string;
            value: string;
        };
        MapInspectorRelationship: {
            label: string;
            layer: components["schemas"]["MapLayer"];
            focus_type: components["schemas"]["MapFocusType"];
            focus_id: string;
        };
        MapInspector: {
            title: string;
            identity: components["schemas"]["MapInspectorField"][];
            status: components["schemas"]["MapInspectorField"][];
            relationships: components["schemas"]["MapInspectorRelationship"][];
        };
        MapProjection: {
            layer: components["schemas"]["MapLayer"];
            focus?: components["schemas"]["MapFocus"];
            /** @description Operator guidance message when the projection is empty or truncated. */
            guidance?: string | null;
            regions: components["schemas"]["MapRegion"][];
            nodes: components["schemas"]["MapNode"][];
            edges: components["schemas"]["MapEdge"][];
            inspector?: components["schemas"]["MapInspector"];
            truncation: components["schemas"]["MapTruncation"];
        };
        Device: {
            /** Format: uuid */
            id: string;
            /** @description Optional human-friendly name. */
            display_name?: string;
            /** @description Best-effort primary IP for UI convenience (may be null when unknown). */
            primary_ip?: string | null;
            /**
             * Format: date-time
             * @description Latest observation timestamp across known facts (best-effort).
             */
            last_seen_at?: string | null;
            /**
             * Format: date-time
             * @description Latest structural change timestamp across known facts (best-effort).
             */
            last_change_at?: string | null;
            metadata?: components["schemas"]["DeviceMetadata"];
        };
        DevicePage: {
            devices: components["schemas"]["Device"][];
            /** @description Cursor for fetching the next page (opaque). */
            cursor?: string;
        };
        DeviceFacts: {
            /** Format: uuid */
            device_id: string;
            ips: components["schemas"]["DeviceIP"][];
            macs: components["schemas"]["DeviceMAC"][];
            interfaces: components["schemas"]["DeviceInterface"][];
            services: components["schemas"]["DeviceService"][];
            snmp?: components["schemas"]["DeviceSNMP"];
            links: components["schemas"]["DeviceLink"][];
        };
        DeviceIP: {
            ip: string;
            /** Format: uuid */
            interface_id?: string | null;
            interface_name?: string | null;
            /** Format: date-time */
            created_at: string;
            /** Format: date-time */
            updated_at: string;
        };
        DeviceMAC: {
            mac: string;
            /** Format: uuid */
            interface_id?: string | null;
            interface_name?: string | null;
            /** Format: date-time */
            created_at: string;
            /** Format: date-time */
            updated_at: string;
        };
        DeviceInterface: {
            /** Format: uuid */
            id: string;
            name?: string | null;
            ifindex?: number | null;
            descr?: string | null;
            alias?: string | null;
            mac?: string | null;
            admin_status?: number | null;
            oper_status?: number | null;
            mtu?: number | null;
            /** Format: int64 */
            speed_bps?: number | null;
            pvid?: number | null;
            /** Format: date-time */
            pvid_observed_at?: string | null;
            /** Format: date-time */
            created_at: string;
            /** Format: date-time */
            updated_at: string;
        };
        DeviceService: {
            /** @enum {string|null} */
            protocol?: "tcp" | "udp" | null;
            port?: number | null;
            name?: string | null;
            /** @enum {string|null} */
            state?: "open" | "closed" | null;
            source?: string | null;
            /** Format: date-time */
            observed_at: string;
            /** Format: date-time */
            created_at: string;
            /** Format: date-time */
            updated_at: string;
        };
        DeviceSNMP: {
            address?: string | null;
            sys_name?: string | null;
            sys_descr?: string | null;
            sys_object_id?: string | null;
            sys_contact?: string | null;
            sys_location?: string | null;
            /** Format: date-time */
            last_success_at?: string | null;
            last_error?: string | null;
            /** Format: date-time */
            updated_at: string;
        };
        DeviceLink: {
            /** Format: uuid */
            id: string;
            link_key: string;
            /** Format: uuid */
            peer_device_id: string;
            /** Format: uuid */
            local_interface_id?: string | null;
            /** Format: uuid */
            peer_interface_id?: string | null;
            link_type?: string | null;
            source: string;
            /** Format: date-time */
            observed_at?: string | null;
            /** Format: date-time */
            updated_at: string;
        };
        /** @description Minimal create payload. Additional fields will be added as the data model is finalized. */
        DeviceCreate: {
            display_name?: string;
            metadata?: components["schemas"]["DeviceMetadata"];
        };
        /** @description Minimal update payload. Additional fields will be added as the data model is finalized. */
        DeviceUpdate: {
            display_name?: string;
            metadata?: components["schemas"]["DeviceMetadata"];
        };
        DeviceNameCandidate: {
            name: string;
            /** @description Candidate source (e.g. snmp, reverse_dns). */
            source: string;
            /** @description Optional IP address the name was observed on. */
            address?: string;
            /** Format: date-time */
            observed_at: string;
        };
        DeviceMetadata: {
            owner?: string;
            location?: string;
            notes?: string;
        };
        DeviceImport: {
            /** Format: uuid */
            id?: string;
            display_name?: string;
            metadata?: components["schemas"]["DeviceMetadata"];
        };
        DeviceImportPayload: {
            devices: components["schemas"]["DeviceImport"][];
        };
        DeviceImportResult: {
            created?: number;
            updated?: number;
        };
        InventoryImportRequest: {
            /** @description Raw upstream inventory JSON (e.g. a NetBox/Nautobot API response with `results[]` or a direct device list). */
            payload: {
                [key: string]: unknown;
            } | {
                [key: string]: unknown;
            }[];
        };
        InventoryImportResult: {
            created?: number;
            matched_existing?: number;
            ip_written?: number;
            metadata_written?: number;
            skipped?: number;
        };
        AuditEventCreate: {
            actor: string;
            actor_role?: string | null;
            action: string;
            target_type?: string | null;
            /** Format: uuid */
            target_id?: string | null;
            details?: {
                [key: string]: unknown;
            };
        };
        DiscoveryRunRequest: {
            /** @description Scan preset controlling runtime budget and enrichment depth. */
            preset?: "fast" | "normal" | "deep";
            /** @description Optional scope hint for the discovery engine. */
            scope?: string;
        };
        DiscoveryRun: {
            /** Format: uuid */
            id: string;
            /** @enum {string} */
            status: "queued" | "running" | "succeeded" | "failed";
            scope?: string | null;
            stats?: {
                [key: string]: unknown;
            };
            /** Format: date-time */
            started_at: string;
            /** Format: date-time */
            completed_at?: string | null;
            last_error?: string | null;
        };
        DiscoveryStatus: {
            /** @description High level status: "idle" when no runs exist, otherwise mirrors the latest run status. */
            status: string;
            latest_run?: components["schemas"]["DiscoveryRun"];
        };
        DeviceChangeEvent: {
            event_id: string;
            /** Format: uuid */
            device_id: string;
            /** Format: date-time */
            event_at: string;
            kind: string;
            summary: string;
            details?: {
                [key: string]: unknown;
            };
        };
        DeviceChangeFeed: {
            events?: components["schemas"]["DeviceChangeEvent"][];
            cursor?: string | null;
        };
        DiscoveryRunPage: {
            runs?: components["schemas"]["DiscoveryRun"][];
            cursor?: string | null;
        };
        DiscoveryRunLogEntry: {
            id: number;
            level: string;
            message: string;
            /** Format: date-time */
            created_at: string;
        };
        DiscoveryRunLogPage: {
            logs?: components["schemas"]["DiscoveryRunLogEntry"][];
            cursor?: string | null;
        };
        ErrorResponse: {
            error: {
                code: string;
                message: string;
                details?: {
                    [key: string]: unknown;
                };
            };
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export type operations = Record<string, never>;
