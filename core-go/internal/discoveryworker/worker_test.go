package discoveryworker
package discoveryworker

import (
	"context"
	"errors"
















































































































































}	}		t.Fatalf("expected at least two update calls, got %d", updateCalls)	if updateCalls < 2 {	}		t.Fatalf("expected error")	if err == nil {	}		t.Fatalf("expected processed=true")	if !processed {	processed, err := w.runOnce(context.Background())	w := New(zerolog.Nop(), q, Options{PollInterval: 0, RunDelay: 0})	}		return nil	q.insertFn = func(ctx context.Context, arg sqlcgen.InsertDiscoveryRunLogParams) error {	}		return sqlcgen.DiscoveryRun{ID: arg.ID, Status: arg.Status}, nil		}			t.Fatalf("expected last_error to be set")		if arg.LastError == nil || *arg.LastError == "" {		}			t.Fatalf("expected second update to set failed, got %q", arg.Status)		if arg.Status != "failed" {		}			return sqlcgen.DiscoveryRun{}, errors.New("boom")		if updateCalls == 1 {		updateCalls++	q.updateFn = func(ctx context.Context, arg sqlcgen.UpdateDiscoveryRunParams) (sqlcgen.DiscoveryRun, error) {	updateCalls := 0	}		return sqlcgen.DiscoveryRun{ID: "run-2", Status: "running"}, nil	q.claimFn = func(ctx context.Context, stats map[string]any) (sqlcgen.DiscoveryRun, error) {	q := &fakeQueries{}func TestWorker_RunOnce_FailsRunWhenUpdateFails(t *testing.T) {}	}		t.Fatalf("expected start and completion logs, got started=%v completed=%v", seenStarted, seenCompleted)	if !seenStarted || !seenCompleted {	}		t.Fatalf("expected run to be updated to succeeded")	if updatedStatus != "succeeded" {	}		t.Fatalf("expected processed=true")	if !processed {	}		t.Fatalf("expected nil error, got %v", err)	if err != nil {	processed, err := w.runOnce(context.Background())	w := New(zerolog.Nop(), q, Options{PollInterval: 0, RunDelay: 0})	}		},			return nil			}				seenCompleted = true			case "discovery run completed":				seenStarted = true			case "discovery run started":			switch arg.Message {		insertFn: func(ctx context.Context, arg sqlcgen.InsertDiscoveryRunLogParams) error {		},			return sqlcgen.DiscoveryRun{ID: arg.ID, Status: arg.Status, StartedAt: now, CompletedAt: arg.CompletedAt}, nil			}				t.Fatalf("expected completed_at to be set")			if arg.CompletedAt == nil {			}				t.Fatalf("expected status succeeded, got %q", arg.Status)			if arg.Status != "succeeded" {			updatedStatus = arg.Status		updateFn: func(ctx context.Context, arg sqlcgen.UpdateDiscoveryRunParams) (sqlcgen.DiscoveryRun, error) {		},			return sqlcgen.DiscoveryRun{ID: "run-1", Status: "running", StartedAt: now}, nil			}				t.Fatalf("expected claim stats stage=running, got %#v", stats)			if stats == nil || stats["stage"] != "running" {		claimFn: func(ctx context.Context, stats map[string]any) (sqlcgen.DiscoveryRun, error) {	q := &fakeQueries{	now := time.Now()	)		updatedStatus string		seenCompleted bool		seenStarted   bool	var (func TestWorker_RunOnce_ClaimsAndCompletes(t *testing.T) {}	}		t.Fatalf("expected processed=false")	if processed {	}		t.Fatalf("expected nil error, got %v", err)	if err != nil {	processed, err := w.runOnce(context.Background())	w := New(zerolog.Nop(), q, Options{PollInterval: 0, RunDelay: 0})	}		},			return nil			t.Fatalf("InsertDiscoveryRunLog should not be called when no rows")		insertFn: func(ctx context.Context, arg sqlcgen.InsertDiscoveryRunLogParams) error {		},			return sqlcgen.DiscoveryRun{}, nil			t.Fatalf("UpdateDiscoveryRun should not be called when no rows")		updateFn: func(ctx context.Context, arg sqlcgen.UpdateDiscoveryRunParams) (sqlcgen.DiscoveryRun, error) {		},			return sqlcgen.DiscoveryRun{}, pgx.ErrNoRows		claimFn: func(ctx context.Context, stats map[string]any) (sqlcgen.DiscoveryRun, error) {	q := &fakeQueries{func TestWorker_RunOnce_NoQueuedRuns(t *testing.T) {}	return f.insertFn(ctx, arg)func (f *fakeQueries) InsertDiscoveryRunLog(ctx context.Context, arg sqlcgen.InsertDiscoveryRunLogParams) error {}	return f.updateFn(ctx, arg)func (f *fakeQueries) UpdateDiscoveryRun(ctx context.Context, arg sqlcgen.UpdateDiscoveryRunParams) (sqlcgen.DiscoveryRun, error) {}	return f.claimFn(ctx, stats)	f.claimHits++func (f *fakeQueries) ClaimNextDiscoveryRun(ctx context.Context, stats map[string]any) (sqlcgen.DiscoveryRun, error) {}	claimHits int	insertFn  func(ctx context.Context, arg sqlcgen.InsertDiscoveryRunLogParams) error	updateFn  func(ctx context.Context, arg sqlcgen.UpdateDiscoveryRunParams) (sqlcgen.DiscoveryRun, error)	claimFn   func(ctx context.Context, stats map[string]any) (sqlcgen.DiscoveryRun, error)type fakeQueries struct {)	"roller_hoops/core-go/internal/sqlcgen"	"github.com/rs/zerolog"	"github.com/jackc/pgx/v5"	"time"	"testing"