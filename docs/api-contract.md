# API contract

This document describes the API rules for Roller_hoops. The API is a **contract**, not an implementation detail.

## Principles

- REST over HTTP
- JSON only
- Explicit error responses (no silent failures)
- Versioned endpoints for stability (`/api/v1`)
- Stable IDs (UUIDs as strings)

## Canonical source

- OpenAPI is canonical: `api/openapi.yaml`
- This document explains conventions and non-obvious rules.

## Versioning

- Current version: `/api/v1`
- Breaking changes require a new version (`/api/v2`).

## Common headers

- Request correlation:
  - `X-Request-Id`: accepted from upstream, otherwise generated by the API.
  - The API echoes the effective request id in the response header (`X-Request-ID`).

## Error format

All non-2xx responses return JSON using a consistent envelope:

- `error.code` (stable string)
- `error.message` (human-readable)
- `error.details` (optional object)

Example shape:

```json
{
  "error": {
    "code": "validation_failed",
    "message": "Request body did not match schema",
    "details": {
      "field": "name"
    }
  }
}
```

## Error codes (current)

- `validation_failed`: JSON could not be decoded or failed schema validation.
- `invalid_id`: path parameter could not be parsed as a UUID.
- `not_found`: requested resource does not exist.
- `db_unavailable`: database connection is missing or not ready.
- `db_error`: unexpected persistence failure.

## Resource conventions

- IDs are UUID strings.
- `PUT` is used for full updates of a resource.
- `POST` is used for creates and command-style actions.
- Device responses include an optional `metadata` object (`owner`, `location`, `notes`). Empty strings are normalised to null.

## Endpoints (v1)

Initial endpoints (from `docs/roadmap.md`):

- Devices
  - `GET /api/v1/devices`
  - `GET /api/v1/devices/{id}`
  - `GET /api/v1/devices/{id}/name-candidates`
  - `GET /api/v1/devices/changes`
  - `GET /api/v1/devices/{id}/history`
  - `POST /api/v1/devices`
  - `PUT /api/v1/devices/{id}`
  - `GET /api/v1/devices/export`
  - `POST /api/v1/devices/import`

- Discovery
  - `POST /api/v1/discovery/run`
  - `GET /api/v1/discovery/status`
  - `GET /api/v1/discovery/runs`
  - `GET /api/v1/discovery/runs/{id}`
  - `GET /api/v1/discovery/runs/{id}/logs`

- Network map (planned)
  - `GET /api/v1/map/{layer}` (layer-aware projections; no global graph)
    - Initial target: `GET /api/v1/map/l3`

### Discovery behaviour (v1)

- `POST /api/v1/discovery/run` accepts an optional `scope` hint; it returns a `DiscoveryRun` with a real run id (queued).
- `GET /api/v1/discovery/status` returns `{status: string, latest_run?: DiscoveryRun}`. Status is `idle` when no runs exist; otherwise it mirrors the latest run’s status.
- Discovery runs are persisted in Postgres (`discovery_runs`, `discovery_run_logs`). The current implementation stubs the worker but wires the API, status, and request id propagation.

### Change feed & device history (v1)

- `GET /api/v1/devices/changes` returns a read-only feed of change events (`event_id`, `device_id`, `event_at`, `kind`, `summary`, `details`) ordered newest-first.
  - Query params: `since` (RFC3339 timestamp, inclusive) and `limit` (defaults to 50, max 100) gate the timeframe; `cursor` encodes `event_at|event_id` for pagination.
  - Response includes `events[]` and optional `cursor` for the next page. Events are deterministic (stable secondary sort on `event_id`).
- `GET /api/v1/devices/{id}/history` scopes the same event feed to a single device. It accepts `limit` (default 50) and `cursor` for paging, and returns 404 when the device ID is unknown.

Both endpoints emit change events derived from observations, metadata edits, display-name updates, and service discoveries so the UI can render a stable timeline without manual joins.

### Discovery run APIs (v1)

- `GET /api/v1/discovery/runs` lists discovery runs sorted by `started_at DESC`. Supports `limit` (default 20, max 200) and `cursor` (`started_at|id`) for paging.
- `GET /api/v1/discovery/runs/{id}` returns one run with its status, scope, stats, and timing.
- `GET /api/v1/discovery/runs/{id}/logs` returns paginated logs (`level`, `message`, `created_at`) for the run; supports `limit` (default 100) and `cursor` (`created_at|log_id`).

Logs are bounded (default 100 entries) and use deterministic cursoring so UI consumers can traverse backward without churn.

## Authentication

v1 intent:

- Authentication and sessions are owned by **ui-node**.
- `core-go` remains headless and is not exposed directly to browsers.

(Exact auth propagation and authorization rules will be pinned in OpenAPI and `docs/architecture.md` once the first implementation lands.)

## Network map projections (planned)

The network map is **projection-first**:

- The API returns a **small, render-ready projection** for a specific layer and focus.
- The API must **not** provide a “whole network graph” endpoint in v1.

### Layers

Layers are mutually exclusive:

- `physical`
- `l2`
- `l3`
- `services`
- `security`

### Focus-driven query

Projection endpoints accept a focus. Proposed query params (exact names live in OpenAPI):

- `focusType`: `device` | `subnet` | `vlan` | `zone` | `service`
- `focusId`: stable identifier for the focus object (UUID for device; other types are layer-defined)
- Optional scoping hints:
  - `depth` (small integer, default 1)
  - `limit` (hard capped)

No focus provided ⇒ return an empty projection + a guidance message (still 200 OK).

### Response shape

Map endpoints return a single JSON object (proposed top-level keys):

- `layer` (string)
- `focus` (object)
- `regions[]` (containers like subnets/zones/VLANs)
- `nodes[]` (devices/interfaces/services)
- `edges[]` (relationships defined by the active layer only)
- `inspector` (render-ready details for the focused object)

Rules:

- The response should be deterministic (stable sorting, stable IDs).
- Avoid overloading `edges`; prefer region membership + a small number of intentional connectors.
- Errors use the standard error envelope (see “Error format”).

### Error handling expectations

- Invalid focus IDs return `400 invalid_id`.
- Unknown focus resources return `404 not_found`.
- Unknown layer returns `400 validation_failed` (or a specific `invalid_layer` if introduced).
