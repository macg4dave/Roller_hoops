# API contract

This document describes the API rules for Roller_hoops. The API is a **contract**, not an implementation detail.

## Principles

- REST over HTTP
- JSON only
- Explicit error responses (no silent failures)
- Versioned endpoints for stability (`/api/v1`)
- Stable IDs (UUIDs as strings)

## Canonical source

- OpenAPI is canonical: `api/openapi.yaml`
- This document explains conventions and non-obvious rules.

## Versioning

- Current version: `/api/v1`
- Breaking changes require a new version (`/api/v2`).

## Common headers

- Request correlation:
  - `X-Request-Id`: accepted from upstream, otherwise generated by the API.
  - The API echoes the effective request id in the response header (`X-Request-ID`).

## Error format

All non-2xx responses return JSON using a consistent envelope:

- `error.code` (stable string)
- `error.message` (human-readable)
- `error.details` (optional object)

Example shape:

```json
{
  "error": {
    "code": "validation_failed",
    "message": "Request body did not match schema",
    "details": {
      "field": "name"
    }
  }
}
```

## Error codes (current)

- `validation_failed`: JSON could not be decoded or failed schema validation.
- `invalid_id`: path parameter could not be parsed as a UUID.
- `not_found`: requested resource does not exist.
- `db_unavailable`: database connection is missing or not ready.
- `db_error`: unexpected persistence failure.

## Resource conventions

- IDs are UUID strings.
- `PUT` is used for full updates of a resource.
- `POST` is used for creates and command-style actions.
- Device responses include an optional `metadata` object (`owner`, `location`, `notes`). Empty strings are normalised to null.

## Endpoints (v1)

Initial endpoints (from `docs/roadmap.md`):

- Devices
  - `GET /api/v1/devices`
  - `GET /api/v1/devices/{id}`
  - `GET /api/v1/devices/{id}/name-candidates`
  - `GET /api/v1/devices/changes`
  - `GET /api/v1/devices/{id}/history`
  - `POST /api/v1/devices`
  - `PUT /api/v1/devices/{id}`
  - `GET /api/v1/devices/export`
  - `POST /api/v1/devices/import`

- Discovery
  - `POST /api/v1/discovery/run`
  - `GET /api/v1/discovery/status`
  - `GET /api/v1/discovery/runs`
  - `GET /api/v1/discovery/runs/{id}`
  - `GET /api/v1/discovery/runs/{id}/logs`

- Network map projections
  - `GET /api/v1/map/{layer}` (layer-aware projections; no global graph)
    - L3 projections are live at `GET /api/v1/map/l3`

### Discovery behaviour (v1)

- `POST /api/v1/discovery/run` accepts an optional `scope` hint; it returns a `DiscoveryRun` with a real run id (queued).
- `GET /api/v1/discovery/status` returns `{status: string, latest_run?: DiscoveryRun}`. Status is `idle` when no runs exist; otherwise it mirrors the latest run’s status.
- Discovery runs are persisted in Postgres (`discovery_runs`, `discovery_run_logs`). The current implementation stubs the worker but wires the API, status, and request id propagation.

### Change feed & device history (v1)

- `GET /api/v1/devices/changes` returns a read-only feed of change events (`event_id`, `device_id`, `event_at`, `kind`, `summary`, `details`) ordered newest-first.
  - Query params: `since` (RFC3339 timestamp, inclusive) and `limit` (defaults to 50, max 100) gate the timeframe; `cursor` encodes `event_at|event_id` for pagination.
  - Response includes `events[]` and optional `cursor` for the next page. Events are deterministic (stable secondary sort on `event_id`).
- `GET /api/v1/devices/{id}/history` scopes the same event feed to a single device. It accepts `limit` (default 50) and `cursor` for paging, and returns 404 when the device ID is unknown.

Both endpoints emit change events derived from observations, metadata edits, display-name updates, and service discoveries so the UI can render a stable timeline without manual joins.

### Discovery run APIs (v1)

- `GET /api/v1/discovery/runs` lists discovery runs sorted by `started_at DESC`. Supports `limit` (default 20, max 200) and `cursor` (`started_at|id`) for paging.
- `GET /api/v1/discovery/runs/{id}` returns one run with its status, scope, stats, and timing.
- `GET /api/v1/discovery/runs/{id}/logs` returns paginated logs (`level`, `message`, `created_at`) for the run; supports `limit` (default 100) and `cursor` (`created_at|log_id`).

Logs are bounded (default 100 entries) and use deterministic cursoring so UI consumers can traverse backward without churn.

## Observability

- `GET /metrics` exports Prometheus metrics from `core-go` (currently `roller_http_requests_total`, `roller_http_request_duration_seconds`, `roller_discovery_runs_total`, and `roller_discovery_run_duration_seconds`).
- The endpoint should be scraped through Traefik/internal load balancers and is not intended for public exposure. All metrics live under the `roller` namespace and stay stable across releases.

## Authentication

v1 intent:

- Authentication and sessions are owned by **ui-node**.
- `core-go` remains headless and is not exposed directly to browsers.

Implementation details:

- `GET /auth/login` renders the login form that captures the operator credentials.
- `POST /api/auth/login` validates `username`/`password` against `AUTH_USERNAME` / `AUTH_PASSWORD` (see `.env.example`) and issues a signed `roller_session` cookie.
- The stock `.env.example` seeds a single admin user (`admin` / `admin`) so the login call succeeds out of the box for local quickstarts.
- `POST /api/auth/logout` clears the `roller_session` cookie to force the UI back to the login screen.
- The `roller_session` cookie is `HttpOnly`, `SameSite=Lax`, and marked `Secure` in production; it is signed with `AUTH_SESSION_SECRET` and expires after 24 hours.
- The UI checks the `roller_session` cookie before proxying any `/api` requests, ensuring the Go API stays inaccessible until authentication succeeds.

Role-aware UX (admin vs read-only) is enforced in the UI layer; `core-go` remains headless and does not consume UI session state.

## UI-driven API evolution (Phase 12)

Phase 12 focuses on operator workflows (filters/search/sort/paging) and may require new optional query parameters on existing endpoints (especially `GET /api/v1/devices`).

Rules:

- **OpenAPI is canonical**: do not ship UI features that rely on undocumented query params.
- Prefer small, explicit query params (filter/sort/search/paging) over “return everything then filter in the browser”.
- Keep ordering deterministic and cursor paging stable to avoid UI churn.

## Network map projections

The network map is **projection-first**:

- The API returns a **small, render-ready projection** for a specific layer and focus.
- The API must **not** provide a “whole network graph” endpoint in v1.

### Layers

Layers are mutually exclusive:

- `physical`
- `l2`
- `l3`
- `services`
- `security`

### Focus-driven query

Projection endpoints accept a focus. Query params (exact names live in OpenAPI):

- `focusType`: `device` | `subnet` | `vlan` | `zone` | `service`
- `focusId`: stable identifier for the focus object (UUID for device; other types are layer-defined)
- Optional scoping hints:
  - `depth` (small integer, default 1)
  - `limit` (hard capped)

No focus provided ⇒ return an empty projection + a guidance message (still 200 OK).

### Response shape

Map endpoints return a single JSON object (top-level keys):

- `layer` (string)
- `focus` (object)
- `regions[]` (containers like subnets/zones/VLANs)
- `nodes[]` (devices/interfaces/services)
- `edges[]` (relationships defined by the active layer only)
- `inspector` (render-ready details for the focused object)

Rules:

- The response should be deterministic (stable sorting, stable IDs).
- Avoid overloading `edges`; prefer region membership + a small number of intentional connectors.
- Errors use the standard error envelope (see “Error format”).

Container guidance (important for “objects that contain other objects”):

- Treat **Subnet/VLAN/Zone** as first-class **container objects** in `regions[]`.
- Treat **Devices/Interfaces/Services** as occupant objects in `nodes[]`.
- Prefer expressing “lives inside” as **region membership** (so the canvas can show stacked regions without edge spaghetti).
- “Server/router/switch” should be represented as a **device kind/role** on a device node (icon/label/filtering), not separate entity tables.

### Error handling expectations

- Invalid focus IDs return `400 invalid_id`.
- Unknown focus resources return `404 not_found`.
- Unknown layer returns `400 validation_failed` (or a specific `invalid_layer` if introduced).
